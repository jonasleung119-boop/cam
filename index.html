<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flux ç²’å­ç³»çµ± Pro - æ‰‹å‹¢æ§åˆ¶</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            /* åŠ å…¥å¾‘å‘æ¼¸å±¤èƒŒæ™¯ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ */
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }
        #video-input {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            border-radius: 10px;
            z-index: 2;
            opacity: 0.6;
            display: none;
            object-fit: cover;
            border: 1px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none;
            max-width: 320px;
        }
        h1 {
            margin: 0;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            background: linear-gradient(90deg, #00ffff, #ffffff, #ff00ff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shine 3s linear infinite;
        }
        @keyframes shine {
            to { background-position: 200% center; }
        }
        .status { margin-top: 5px; font-size: 0.9rem; color: #aaa; font-weight: bold; }
        .controls {
            margin-top: 20px;
            background: rgba(10, 10, 20, 0.85);
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #00ffff;
            backdrop-filter: blur(8px);
            font-size: 0.85rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .control-item { margin-bottom: 6px; display: flex; align-items: center; }
        .key { font-weight: bold; color: #00ffff; margin-right: 10px; min-width: 90px; text-align: right; }
        .icon { margin-right: 8px; font-size: 1.2em; width: 20px; text-align: center; }
        
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 1.2rem;
            z-index: 20;
            text-align: center;
        }
        
        .gesture-feedback {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.8rem;
            font-weight: bold;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            letter-spacing: 2px;
        }

        #log-panel {
            position: absolute;
            top: 20px; right: 20px;
            width: 250px; height: 180px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 11px;
            padding: 10px;
            overflow-y: auto;
            z-index: 5;
            color: #0f0;
            pointer-events: auto;
        }
        .log-entry { margin-bottom: 3px; border-bottom: 1px solid #222; padding-bottom: 1px; }
        .log-time { color: #666; margin-right: 5px; }
        .log-info { color: #0f0; } 
        .log-warn { color: #fa0; } 
        .log-error { color: #f00; }
        
        /* æˆªåœ–æŒ‰éˆ•æ¨£å¼ */
        #btn-snapshot {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 4px;
            transition: all 0.3s;
        }
        #btn-snapshot:hover {
            background: #00ffff;
            color: black;
            box-shadow: 0 0 15px #00ffff;
        }
    </style>
</head>
<body>

    <div id="loader">åˆå§‹åŒ–ç¥ç¶“ç¶²çµ¡...<br><span style="font-size:0.8em; color:#ccc">è«‹æˆäºˆç›¸æ©Ÿæ¬Šé™</span></div>
    
    <div id="ui-layer">
        <h1>Flux ç²’å­ç³»çµ± Pro</h1>
        <div class="status" id="status-text">ç­‰å¾…ä»‹é¢å•Ÿå‹•...</div>
        <div class="controls">
            <div style="margin-bottom:10px; border-bottom:1px solid #444; padding-bottom:5px; color:#fff">
                ğŸ‘‹ <b>æ®å‹•æ‰‹éƒ¨</b> å¯æ¨é–‹ç²’å­ (åŠ›å ´)<br>
                âŒ¨ï¸ æŒ‰ <b>S</b> éµæˆªåœ–
            </div>
            <div class="control-item"><span class="icon">â˜ï¸</span><span class="key">é£ŸæŒ‡</span> æ˜Ÿå½¢ (Star)</div>
            <div class="control-item"><span class="icon">âœŒï¸</span><span class="key">äºŒæŒ‡ (V)</span> åœŸæ˜Ÿ (Saturn)</div>
            <div class="control-item"><span class="icon">ğŸ¤˜</span><span class="key">æ–æ»¾</span> é‡‘å­—å¡” (Pyramid)</div>
            <div class="control-item"><span class="icon">ğŸ¤™</span><span class="key">å…­</span> æ™‚ç©ºéš§é“ (Tunnel)</div>
            <div class="control-item"><span class="icon">ğŸ‘Œ</span><span class="key">ä¸‰æŒ‡</span> DNA èºæ—‹ (Helix)</div>
            <div class="control-item"><span class="icon">ğŸ–</span><span class="key">äº”æŒ‡</span> é‡å­ç¶²æ ¼ (Grid)</div>
            <div class="control-item"><span class="icon">âœŠ</span><span class="key">æ¡æ‹³</span> é»‘æ´ (Black Hole)</div>
            <div class="control-item"><span class="icon">ğŸ¤</span><span class="key">æåˆ</span> ç¸®æ”¾ç²’å­</div>
        </div>
    </div>

    <div id="log-panel">
        <div class="log-entry"><span class="log-time">System</span><span class="log-info">ç³»çµ±æ ¸å¿ƒå•Ÿå‹•...</span></div>
    </div>

    <div class="gesture-feedback" id="gesture-feedback">æ¨¡å¼: æ˜Ÿå½¢</div>
    <button id="btn-snapshot">ğŸ“¸ æ‹æ”å¿«ç…§</button>

    <video id="video-input" autoplay muted playsinline></video>
    <div id="canvas-container"></div>

<script>
    // --- æ—¥èªŒç³»çµ± ---
    function addLog(message, type = 'info') {
        const panel = document.getElementById('log-panel');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const timeStr = new Date().toLocaleTimeString('zh-TW', { hour12: false, hour: '2-digit', minute:'2-digit', second:'2-digit' });
        let colorClass = 'log-info';
        if (type === 'warn') colorClass = 'log-warn';
        if (type === 'error') colorClass = 'log-error';
        entry.innerHTML = `<span class="log-time">[${timeStr}]</span><span class="${colorClass}">${message}</span>`;
        panel.appendChild(entry);
        panel.scrollTop = panel.scrollHeight;
    }

    // --- åƒæ•¸è¨­å®š ---
    const CONFIG = {
        particleCount: 20000,
        particleSize: 0.15,
        repulsionRadius: 3.5, // æ‰‹éƒ¨æ–¥åŠ›å ´åŠå¾‘
        repulsionStrength: 5.0, // æ–¥åŠ›å¼·åº¦
    };
    
    const state = {
        targetShape: 'sphere', 
        handDetected: false,
        pinchDistance: 0.5,
        handPosition: { x: 0, y: 0 }, // MediaPipe 0-1 coords
        worldHandPosition: new THREE.Vector3(0, 0, 0), // 3D World coords
        currentColor: new THREE.Color(0x00ffff),
        targetColor: new THREE.Color(0x00ffff),
    };

    // --- THREE.JS å ´æ™¯ ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    // ç§»é™¤å ´æ™¯éœ§æ°£ï¼Œæ”¹ç”¨èƒŒæ™¯å¢å¼·æ·±åº¦
    // scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true, 
        preserveDrawingBuffer: true // å…è¨±æˆªåœ–
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ•ˆèƒ½å„ªåŒ–
    container.appendChild(renderer.domElement);

    // [æ–°å¢] èƒŒæ™¯ç¶²æ ¼çƒé«” (å¢åŠ ç©ºé–“æ„Ÿ)
    const bgGeometry = new THREE.IcosahedronGeometry(15, 1);
    const bgMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x333333, 
        wireframe: true, 
        transparent: true, 
        opacity: 0.15 
    });
    const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
    scene.add(bgMesh);

    // --- ç²’å­ç³»çµ±åˆå§‹åŒ– ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const targetPositions = new Float32Array(CONFIG.particleCount * 3);
    const colors = new Float32Array(CONFIG.particleCount * 3);
    const sizes = new Float32Array(CONFIG.particleCount);
    const originalSizes = new Float32Array(CONFIG.particleCount); // å„²å­˜åŸå§‹å¤§å°ç”¨æ–¼å‘¼å¸æ•ˆæœ

    const tempColor = new THREE.Color();
    
    for (let i = 0; i < CONFIG.particleCount; i++) {
        const x = (Math.random() - 0.5) * 15;
        const y = (Math.random() - 0.5) * 15;
        const z = (Math.random() - 0.5) * 15;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        targetPositions[i * 3] = x;
        targetPositions[i * 3 + 1] = y;
        targetPositions[i * 3 + 2] = z;

        // åˆå§‹é¡è‰²éš¨æ©Ÿ
        tempColor.setHSL(Math.random(), 0.8, 0.6);
        colors[i * 3] = tempColor.r;
        colors[i * 3 + 1] = tempColor.g;
        colors[i * 3 + 2] = tempColor.b;

        const s = Math.random();
        sizes[i] = s;
        originalSizes[i] = s;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    // Shader ä¿æŒä¸è®Šï¼Œå› ç‚ºå·²ç¶“å¾ˆæ£’äº†
    const material = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0 },
            pointScale: { value: window.innerHeight / 2.0 } // RWD é»å¤§å°èª¿æ•´
        },
        vertexShader: `
            attribute float size;
            varying vec3 vColor;
            uniform float pointScale;
            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (pointScale / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            void main() {
                // åœ“å½¢ç²’å­
                vec2 coord = gl_PointCoord - vec2(0.5);
                float r = length(coord);
                if (r > 0.5) discard;
                
                // æŸ”å’Œé‚Šç·£ (Glow æ•ˆæœ)
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 1.5);
                
                gl_FragColor = vec4(vColor, glow);
            }
        `,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- å½¢ç‹€ç”Ÿæˆé‚è¼¯ (æ•¸å­¸é­”æ³•) ---
    // [æ–°å¢] è¼”åŠ©å‡½æ•¸ï¼šçƒé¢åˆ†ä½ˆ
    function getPointOnSphere(r = 4) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    // æ˜Ÿå½¢
    function getPointOnStar() {
        const angle = Math.random() * Math.PI * 2;
        const n = 5; 
        const sectorAngle = Math.PI * 2 / n;
        const localAngle = (angle % sectorAngle) / sectorAngle;
        const dist = Math.abs(localAngle - 0.5) * 2; 
        const inner = 2.0; const outer = 6.0;
        const r = inner + (outer - inner) * dist;
        const z = (Math.random() - 0.5) * 3 * (1 - dist * 0.5); 
        const finalAngle = angle - (Math.PI / 10); 
        return { x: r * Math.cos(finalAngle), y: r * Math.sin(finalAngle), z: z };
    }

    // åœŸæ˜Ÿ
    function getPointOnSaturn() {
        const isRing = Math.random() > 0.5;
        if (isRing) {
            const angle = Math.random() * Math.PI * 2;
            const r = 5.5 + Math.random() * 3;
            return { x: Math.cos(angle)*r, y: (Math.random()-0.5)*0.2, z: Math.sin(angle)*r };
        }
        return getPointOnSphere(3.0);
    }

    // é‡‘å­—å¡”
    function getPointOnPyramid() {
        const h = 7; const base = 7;
        const face = Math.floor(Math.random() * 5);
        let x, y, z;
        if (face < 4) {
            y = (Math.random() - 0.5) * h;
            const scale = (h/2 - y) / h;
            x = (Math.random() - 0.5) * base * scale * 2;
            z = (Math.random() - 0.5) * base * scale * 2;
        } else {
            y = -h/2; x = (Math.random()-0.5)*base; z = (Math.random()-0.5)*base;
        }
        return {x,y,z};
    }

    // éš§é“
    function getPointOnTunnel() {
        const z = (Math.random() - 0.5) * 30;
        const angle = Math.random() * Math.PI * 2;
        const r = 3 + Math.random();
        return { x: Math.cos(angle)*r, y: Math.sin(angle)*r, z };
    }

    // é»‘æ´ (å¸ç©ç›¤)
    function getPointOnBlackHole() {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random();
        // é è¿‘ä¸­å¿ƒå¯†é›†ï¼Œé é›¢ç¨€ç–
        const r = 1.5 + dist * dist * 8; 
        const h = 1.0 / (r * 0.5) * (Math.random() - 0.5);
        return { x: Math.cos(angle)*r, y: h, z: Math.sin(angle)*r };
    }

    // èºæ—‹
    function getPointOnHelix() {
        const t = (Math.random() - 0.5) * 15;
        const angle = t * 1.5;
        const r = 3;
        const offset = Math.random() > 0.5 ? 0 : Math.PI;
        return { x: Math.cos(angle+offset)*r, y: t, z: Math.sin(angle+offset)*r };
    }

    // ç¶²æ ¼
    function getPointOnGrid() {
        const s = 6;
        const x = (Math.floor(Math.random()*s) - s/2) * 1.8;
        const y = (Math.floor(Math.random()*s) - s/2) * 1.8;
        const z = (Math.floor(Math.random()*s) - s/2) * 1.8;
        return {x,y,z};
    }

    // å½¢ç‹€åˆ‡æ›å™¨
    function morphToShape(shape) {
        if (state.targetShape === shape) return;
        state.targetShape = shape;
        
        const feedback = document.getElementById('gesture-feedback');
        let text = "", colorHex = 0xffffff;

        switch(shape) {
            case 'star': text="æ˜Ÿå½¢ (Star)"; colorHex=0xffd700; break;
            case 'saturn': text="åœŸæ˜Ÿ (Saturn)"; colorHex=0xffaa00; break;
            case 'pyramid': text="é‡‘å­—å¡” (Pyramid)"; colorHex=0xff00ff; break;
            case 'tunnel': text="æ™‚ç©ºéš§é“ (Tunnel)"; colorHex=0x00ffff; break;
            case 'helix': text="DNA èºæ—‹ (Helix)"; colorHex=0x00ff88; break;
            case 'grid': text="é‡å­ç¶²æ ¼ (Grid)"; colorHex=0xaa00ff; break;
            case 'blackhole': text="é»‘æ´ (Black Hole)"; colorHex=0xff3333; break;
            case 'tower': text="æ‘©å¤©æ¨“ (Tower)"; colorHex=0x0088ff; break;
            default: text="çƒé«” (Sphere)"; colorHex=0xffffff;
        }

        state.targetColor.setHex(colorHex);
        feedback.innerText = "æ¨¡å¼: " + text;
        feedback.style.opacity = 1;
        feedback.style.textShadow = `0 0 20px #${state.targetColor.getHexString()}`;
        
        addLog(`è®Šå½¢å•Ÿå‹•: ${text}`);

        for(let i=0; i<CONFIG.particleCount; i++) {
            let p;
            if(shape === 'star') p = getPointOnStar();
            else if(shape === 'saturn') p = getPointOnSaturn();
            else if(shape === 'pyramid') p = getPointOnPyramid();
            else if(shape === 'tunnel') p = getPointOnTunnel();
            else if(shape === 'helix') p = getPointOnHelix();
            else if(shape === 'grid') p = getPointOnGrid();
            else if(shape === 'blackhole') p = getPointOnBlackHole();
            else p = getPointOnSphere();
            
            targetPositions[i*3] = p.x;
            targetPositions[i*3+1] = p.y;
            targetPositions[i*3+2] = p.z;
        }
    }

    // --- å‹•ç•«è¿´åœˆ (æ ¸å¿ƒç‰©ç†) ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // æ›´æ–°èƒŒæ™¯
        bgMesh.rotation.y = time * 0.05;
        bgMesh.rotation.z = time * 0.02;

        // é¡è‰²æ¼¸è®Š
        state.currentColor.lerp(state.targetColor, 0.05);

        // æ‰‹éƒ¨ä½ç½®è½‰æ› (MediaPipe [0,1] -> 3D World [-x, +x])
        // å‡è¨­ Camera Z=10, FOV=75, æˆ‘å€‘å¤§ç´„åœ¨ Z=0 å¹³é¢æ“ä½œ
        // é€™è£¡åšä¸€å€‹ç°¡å–®çš„æ˜ å°„
        if(state.handDetected) {
            const range = 14; 
            const targetX = (state.handPosition.x - 0.5) * range;
            const targetY = (state.handPosition.y - 0.5) * -range; // Yè»¸åè½‰
            // å¹³æ»‘ç§»å‹•æ‰‹éƒ¨è™›æ“¬åº§æ¨™
            state.worldHandPosition.x += (targetX - state.worldHandPosition.x) * 0.1;
            state.worldHandPosition.y += (targetY - state.worldHandPosition.y) * 0.1;
            state.worldHandPosition.z += (0 - state.worldHandPosition.z) * 0.1;
        }

        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;
        const sizeAttr = geometry.attributes.size;

        const globalScale = 0.5 + (state.pinchDistance * 1.5);
        
        // ç‰¹æ®Šæ—‹è½‰é‚è¼¯
        let autoRotateY = 0;
        if(state.targetShape === 'blackhole') autoRotateY = 2.0;
        if(state.targetShape === 'tunnel') autoRotateY = 1.0;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const ix = i * 3;
            
            // 1. è¨ˆç®—ç›®æ¨™ä½ç½®
            let tx = targetPositions[ix] * globalScale;
            let ty = targetPositions[ix+1] * globalScale;
            let tz = targetPositions[ix+2] * globalScale;

            // 2. æ‡‰ç”¨è‡ªå‹•æ—‹è½‰ (é»‘æ´/éš§é“)
            if (autoRotateY > 0) {
                const angle = time * autoRotateY * (0.2 + (i%10)*0.01);
                const rx = tx * Math.cos(angle) - tz * Math.sin(angle);
                const rz = tx * Math.sin(angle) + tz * Math.cos(angle);
                tx = rx; tz = rz;
            }

            // 3. åŸºæœ¬ç§»å‹• (Lerp)
            const cx = positions[ix];
            const cy = positions[ix+1];
            const cz = positions[ix+2];
            
            let vx = (tx - cx) * 3.0 * delta;
            let vy = (ty - cy) * 3.0 * delta;
            let vz = (tz - cz) * 3.0 * delta;

            // 4. [æ–°å¢] ç‰©ç†åŠ›å ´ï¼šå¦‚æœæ‰‹é è¿‘ï¼Œå°‡ç²’å­æ¨é–‹
            if (state.handDetected) {
                const dx = cx - state.worldHandPosition.x;
                const dy = cy - state.worldHandPosition.y;
                const dz = cz; // å‡è¨­æ‰‹åœ¨ Z=0
                const distSq = dx*dx + dy*dy + dz*dz;
                
                if (distSq < CONFIG.repulsionRadius * CONFIG.repulsionRadius) {
                    const dist = Math.sqrt(distSq);
                    const force = (1.0 - dist / CONFIG.repulsionRadius) * CONFIG.repulsionStrength;
                    
                    // æ·»åŠ éš¨æ©Ÿæ“¾å‹•è®“æ–¥åŠ›çœ‹èµ·ä¾†åƒèƒ½é‡æµ
                    const noise = Math.random() * 0.2;
                    vx += (dx / dist) * force * (1 + noise) * delta * 10;
                    vy += (dy / dist) * force * (1 + noise) * delta * 10;
                    vz += (dz / dist) * force * (1 + noise) * delta * 10;
                }
            }

            positions[ix] += vx;
            positions[ix+1] += vy;
            positions[ix+2] += vz;

            // 5. é¡è‰²èˆ‡é–ƒçˆ
            // æ ¹æ“šä½ç½®ç¨å¾®æ”¹è®Šäº®åº¦ï¼Œè£½é€ ç«‹é«”æ„Ÿ
            const distFromCenter = Math.sqrt(positions[ix]**2 + positions[ix+1]**2);
            const brightness = 0.5 + Math.sin(time * 2 + distFromCenter) * 0.2;

            colAttr.setXYZ(i, 
                state.currentColor.r * brightness,
                state.currentColor.g * brightness,
                state.currentColor.b * brightness
            );
            
            // å‘¼å¸æ•ˆæœå¤§å°
            sizeAttr.setX(i, originalSizes[i] * (0.8 + Math.sin(time * 3 + i) * 0.3));
        }

        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
        sizeAttr.needsUpdate = true;

        // å ´æ™¯æ•´é«”æ—‹è½‰ (å¦‚æœä¸æ“ä½œæ‰‹éƒ¨ï¼Œå ´æ™¯æœƒè‡ªå·±æ…¢è½‰)
        if (!state.handDetected) {
            scene.rotation.y += 0.002;
        } else {
            // æ‰‹éƒ¨æ§åˆ¶å ´æ™¯å‚¾æ–œ (è¦–å·®æ•ˆæœ)
            const targetRotX = (state.handPosition.y - 0.5) * 0.5;
            const targetRotY = (state.handPosition.x - 0.5) * 0.5;
            scene.rotation.x += (targetRotX - scene.rotation.x) * 0.1;
            scene.rotation.y += (targetRotY - scene.rotation.y) * 0.1;
        }

        renderer.render(scene, camera);
    }

    animate();
    morphToShape('sphere');

    // --- MediaPipe è™•ç† ---
    const videoElement = document.getElementById('video-input');
    const statusText = document.getElementById('status-text');
    const loader = document.getElementById('loader');

    function onResults(results) {
        if (loader.style.display !== 'none') {
            loader.style.display = 'none';
            videoElement.style.display = 'block';
            addLog("è¦–è¦ºæ ¸å¿ƒé€£ç·šæˆåŠŸ");
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            if (!state.handDetected) {
                state.handDetected = true;
                statusText.innerText = "è¨Šè™Ÿé–å®š: æ‰‹éƒ¨";
                statusText.style.color = "#00ff00";
            }

            const lm = results.multiHandLandmarks[0];
            
            // è¨ˆç®—ä½ç½®
            state.handPosition.x = 1.0 - (lm[0].x + lm[9].x) / 2;
            state.handPosition.y = (lm[0].y + lm[9].y) / 2;

            // è¨ˆç®—æåˆ
            const p1 = lm[4], p2 = lm[8];
            const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
            state.pinchDistance = Math.min(Math.max((dist - 0.02) * 4, 0), 1.0);

            // æ‰‹æŒ‡ç‹€æ…‹
            const isUp = (tip, pip) => lm[tip].y < lm[pip].y;
            const iUp = isUp(8, 6), mUp = isUp(12, 10), rUp = isUp(16, 14), pUp = isUp(20, 18);
            
            // æ‹‡æŒ‡åˆ¤æ–· (Xè»¸è·é›¢)
            const tUp = Math.abs(lm[4].x - lm[17].x) > 0.15; // ç°¡å–®åˆ¤æ–·å¼µé–‹

            let shape = state.targetShape;
            
            // é‚è¼¯è¡¨
            const count = (iUp?1:0)+(mUp?1:0)+(rUp?1:0)+(pUp?1:0)+(tUp?1:0);

            if (count === 0) shape = 'blackhole'; // æ¡æ‹³
            else if (count === 5) shape = 'grid'; // å¼µé–‹
            else if (iUp && pUp && !mUp && !rUp) shape = 'pyramid'; // Rock
            else if (tUp && pUp && !iUp && !mUp) shape = 'tunnel'; // 6
            else if (iUp && !mUp && !rUp && !pUp) shape = 'star'; // 1
            else if (iUp && mUp && !rUp && !pUp) shape = 'saturn'; // 2
            else if (iUp && mUp && rUp && !pUp) shape = 'helix'; // 3
            else if (iUp && mUp && rUp && pUp && !tUp) shape = 'tower'; // 4

            morphToShape(shape);

        } else {
            if (state.handDetected) {
                state.handDetected = false;
                statusText.innerText = "ç­‰å¾…è¨Šè™Ÿ...";
                statusText.style.color = "#aaa";
                // æ‰‹ç§»é–‹æ™‚æ­¸é›¶æ–¥åŠ›ä½ç½®
                state.worldHandPosition.set(999, 999, 999); 
            }
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    // å•Ÿå‹•ç›¸æ©Ÿ
    navigator.mediaDevices.getUserMedia({video: {width: 640, height: 480}})
        .then(stream => {
            videoElement.srcObject = stream;
            videoElement.onloadeddata = () => {
                const process = async () => {
                    if(videoElement.readyState>=2) await hands.send({image: videoElement});
                    requestAnimationFrame(process);
                };
                process();
            };
        })
        .catch(e => {
            console.error(e);
            loader.innerHTML = "ç„¡æ³•å­˜å–ç›¸æ©Ÿ";
            addLog("éŒ¯èª¤: ç„¡æ³•é€£æ¥ç¡¬é«”", 'error');
        });

    // RWD
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // æ›´æ–° Shader é»å¤§å°æ¯”ä¾‹
        particles.material.uniforms.pointScale.value = window.innerHeight / 2.0;
    });

    // æˆªåœ–åŠŸèƒ½
    document.getElementById('btn-snapshot').addEventListener('click', () => {
        try {
            const strMime = "image/png";
            const imgData = renderer.domElement.toDataURL(strMime);
            const link = document.createElement('a');
            const date = new Date();
            const filename = `Flux_${date.getTime()}.png`;
            
            link.download = filename;
            link.href = imgData;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            addLog(`å·²ä¿å­˜æˆªåœ–: ${filename}`);
            
            // é–ƒå…‰æ•ˆæœ
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = 0; flash.style.left = 0;
            flash.style.width = '100%'; flash.style.height = '100%';
            flash.style.backgroundColor = 'white';
            flash.style.zIndex = 200;
            flash.style.opacity = 1;
            flash.style.transition = 'opacity 0.5s';
            flash.style.pointerEvents = 'none';
            document.body.appendChild(flash);
            setTimeout(() => flash.style.opacity = 0, 50);
            setTimeout(() => document.body.removeChild(flash), 550);

        } catch (e) {
            console.error(e);
            addLog("æˆªåœ–å¤±æ•—", 'error');
        }
    });

    // éµç›¤æ”¯æ´
    window.addEventListener('keydown', (e) => {
        if(e.key.toLowerCase() === 's') document.getElementById('btn-snapshot').click();
    });

</script>
</body>
</html>